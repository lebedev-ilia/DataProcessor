1. Читаешь код компонента, его зависимости, связи с сдругими компонентами и тд. Критерии проверки:

    1. Кикаких fallback, минимум сомнительных эвристик (лучше вообще без них)
    2. Поддержка параллелизма (батчинга), возможно где то async или батчинг в моделях (тут возможно придеться посмотреть в интеренете в репо конкретной модели поддерживает ли она батчинг внутри себя и как). Важго что это должно быть связано с глобальным нашим DynamicBatching (потому что именно он контролирует память и OOM)
    3. Интеграция Triton (возможно Celery)
    4. **ModelManager (обязательное правило для всех модулей и core)**:
        - если компонент/провайдер использует ML-модель (torch/onnx/tensorrt/clip/whisper/sentence-transformers и т.п.), **загрузка/резолв модели должна идти через единый `ModelManager`** (включая core providers).
        - запрещены прямые загрузки “из коробки”, которые могут качать из интернета: `pretrained=True`, `torch.hub.load(...)`, `requests.get(...)` для весов/категорий, `transformers.from_pretrained(...)` без `local_files_only`, `nltk.download(...)`, `clip.load(...)` без локального download_root.
        - на этапе аудита допускается, что не все providers реализованы в ModelManager: тогда мы **дописываем ModelManager** (новый provider/spec) вместе с фиксом компонента.
        - также если в папке компонента лежат модели мы переносим их в dp_models (ModelManager) и удаляем из папки компонента
    4. Документация компонента (обязательно):
        - README **лежит в папке компонента** рядом с кодом (single source of truth).
        - В `docs/` допускаются только **ссылки/индекс** на README компонента (без дублирования контента).
        - В README компонента четко описано:
            1) Основной вход (например аудио сегменты, кадры или группы кадров).
            2) Доп. зависимости которые также считаются входом (например выходы других компонентов).
            3) Выход (все фичи (можно группами) и их описание):
               - краткое описание алгоритма + его оценка от 0 до 10 по реализации,
               - почему фича полезна для модели/аналитики + ее оценка от 0 до 10 по полезности,
               - единицы измерения / диапазоны где применимо.
            4) Sampling / Units-of-processing requirements (обязательно для Visual/Audio/Text; форма зависит от модальности):
               - Visual:
                 - какие кадры нужны и почему (coverage: начало/середина/конец, равномерность, шот-стратификация если нужно),
                 - min/target/max по числу кадров (или по частоте/времени), допустимые границы,
                 - требования к `analysis_fps` и/или к `union_timestamps_sec` (что считать source-of-truth),
                 - требования к разрешению (min/target/max) и запрет/допуск апскейла,
                 - строгий no-fallback: что считается error если sampling/входы не соответствуют.
               - Audio:
                 - какие **time segments** нужны (segment_sec/stride_sec или event-based), min/target/max по числу сегментов/длительности,
                 - требования к sample_rate/mono/stereo и к источнику `audio.wav` (Segmenter),
                 - как компонент выравнивается по time-axis (sec/sample indices) и что является source-of-truth,
                 - no-fallback: что считается error если сегменты/аудио/мета отсутствуют.
               - Text:
                 - единица обработки (токены/строки/предложения/сегменты транскрипта/комменты),
                 - требования к наличию/формату источника (transcript/comments/ocr payload) + политика приватности,
                 - alignment к time-axis если применимо (слова/фразы с start/end), и что делать если alignment невозможен,
                 - no-fallback: что считается error vs валидный empty (например `no_text_available`).
        - Важно: **DEFERRED** только синтез глобальной `SamplingPolicy` в Segmenter.
          Но **требования каждого компонента к выборке** должны быть зафиксированы уже в его README во время аудита.
    5. Общее качество кода (+логики) и готовность к продакшену
    6. Полное соответсвие документам проекта
    7. Контракт артефакта и совместимость:
        - Точный путь/имя артефакта (npz/json/папка) и стабильность имени (важно для downstream).
        - Схема: обязательные ключи, dtype/shape, единицы измерения, допустимые диапазоны.
        - Empty semantics: что считается валидным `empty`, а что `error`; список `empty_reason` (строго фиксированный).
        - No-fallback policy: отсутствующие входы/зависимости → fail-fast.
    8. Reproducibility / Model system:
        - Для model-based компонентов обязательно `models_used[]` + `model_signature` (канонические поля runtime/engine/precision/device/version/weights_digest).
        - Детеминизм: где возможна недетерминированность (random seeds, cudnn, multithreading) и как она контролируется.
        - Версионирование: что должно попадать в meta (producer_version, schema_version, created_at, config_hash, sampling_policy_version, dataprocessor_version где применимо).
    9. State/manifest/observability:
        - Какие статусы пишет компонент (ok/empty/error/skipped) и какие причины ошибок логирует.
        - Что должно попадать в `manifest.json` (артефакты, ошибки, версии, device_used, error_code если есть).
        - Логи: ключевые поля (video_id/run_id/component), отсутствие “тихих” провалов.
    10. Производительность и память:
        - Оценка сложности (time/mem), потенциальные bottleneck’и, горячие циклы.
        - Политика батчинга: какие тензоры/батчи, где лимиты, как это связано с глобальным DynamicBatching.
        - Деградация: что происходит при OOM/timeout (желательно управляемо и прозрачно).
    11. Инфраструктурные зависимости:
        - Внешние бинарники (ffmpeg/ffprobe), сетевые зависимости (Triton/Redis/MinIO) и режимы fail-fast/optional.
        - Лицензии/модели: источники весов, совместимость лицензий (минимальный чек).
    12. Тестируемость:
        - Минимальный smoke-test (маленькое видео/несколько кадров) и ожидаемые артефакты.
        - Валидация артефакта (`artifact_validator`) и проверка метаданных.
    13. Acceptance criteria (когда компонент “закрыт”):
        - README/contract есть и актуален.
        - Артефакт и meta стабильны и валидируются.
        - Empty/error семантика определена и покрыта логами.
        - Для моделей: `models_used[]/model_signature` детерминированы.
        - Компонент проходит smoke-run в baseline профиле (если применимо).

2. Ты задаешь мне все вопросы касательно компонента: это может быть неэффектиынй вход или какая то связь с компонентами или например какие то фичи тебе кажуться неинформативными и ты считаешь что они будут мешать модели и не нужны для аналитик + возможно у тебя есть предложения по добавлению новых фичей

3. Я на все отвечаю
4. Ты все исправляешь: что то можешь удалить, что то дописать. Обязательно четко все документируешь (4 пункт - критерии проверки). Важно понимать что должен получаться полуфинальный вариант компонента который мы уже не будем сильно (или вообще не будем) менять до продакшена и далее.
