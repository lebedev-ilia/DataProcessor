## Error handling and edge cases (MVP) — полуфинал

Этот документ фиксирует правила обработки ошибок, retry политики и edge cases.

### 1) Retry политика

**Retry только transient errors** (2-3 попытки с exponential backoff):

**Ретраим**:
- Network errors (connection timeout, DNS failure)
- Timeout errors (component превысил timeout)
- OOM (Out of Memory) — если компонент поддерживает уменьшение batch_size
- Triton unavailable (503 Service Unavailable)

**НЕ ретраим** (fail-fast):
- Missing dependency (frame_indices отсутствуют)
- Invalid input (повреждённое видео, неподдерживаемый формат)
- Logic errors (алгоритм вернул ошибку валидации)
- Authentication errors (неверный API key)

**Реализация**: использовать библиотеку `tenacity` (Python) или встроенные retry в queue (Celery/RQ).

### 2) Network errors

**YouTube download**:
- 3 попытки с backoff: `[5s, 15s, 30s]` (для скачивания нужны более длинные интервалы)
- Дополнительно: проверять размер файла после скачивания (если < 1MB → вероятно ошибка)

**Triton**:
- 2 попытки для transient errors (503, 504, connection timeout)
- Если модель не найдена (404) → fail-fast (не ретраим)
- Если authentication error (401) → fail-fast

**LLM gateway**:
- 2 попытки для network/timeout errors
- Rate limit (429): возвращаем ошибку пользователю с сообщением "Сервис перегружен, попробуйте позже"
- Не ретраим при 4xx errors (bad request, auth errors)

### 3) OOM (Out of Memory) handling

**OOM handling с fallback**:
- **Первый уровень**: компоненты должны иметь конфигурируемый `batch_size`/`chunk_size`
- **При OOM**: автоматически уменьшаем batch_size в 2 раза и ретраим (максимум 2 попытки)
- **Если всё равно OOM**: помечаем run как `status="error"`, `error="out_of_memory"`, `notes="requires_more_resources"`
- **Мониторинг**: логируем все OOM случаи для анализа (какие компоненты/видео вызывают проблемы)
- **Профилактика**: в проде должны быть лимиты на размер видео/разрешение, чтобы минимизировать OOM
- **Альтернатива**: можно добавить "lightweight mode" для больших видео (автоматически уменьшаем resolution/batch_size)

**Важно**: OOM не должно быть в проде при правильной конфигурации ресурсов.

### 4) Edge cases

#### Видео > 20 минут

- **Валидация на входе**: Backend проверяет длительность видео ДО создания run (из мета YouTube или пользовательского ввода)
- **Если > 20 минут**: возвращаем ошибку сразу (не создаём run, не списываем кредиты)
- **Сообщение пользователю**: "Видео слишком длинное (максимум 20 минут). Пожалуйста, обрежьте видео или выберите другой файл."

#### Повреждённые/некорректные видео файлы

**Автоматическое исправление через ffmpeg**:
- **Шаг 1**: пытаемся прочитать видео через ffmpeg с опцией `-err_detect ignore_err` (игнорирует мелкие ошибки)
- **Шаг 2**: если не получилось → пытаемся перекодировать: `ffmpeg -i input -c:v libx264 -c:a aac -preset slow -crf 18 output.mp4`
  - `-preset slow`: лучшее качество (медленнее, но без потерь)
  - `-crf 18`: практически lossless (CRF 0 = полностью lossless, но файл огромный)
- **Шаг 3**: если перекодирование не помогло → `error="video_file_corrupted"`, отказываемся обрабатывать
- **Логирование**: записываем все попытки исправления в `manifest.json` для анализа
- **Timeout**: на исправление даём максимум 5 минут (если дольше → считаем файл некорректным)
- **Качество**: `-crf 18` даёт визуально идентичное качество, но файл может быть немного больше оригинала

#### Видео без звука

- AudioProcessor компоненты получают `status="empty"`, `empty_reason="audio_missing_or_extract_failed"`
- Run продолжается (видео компоненты обрабатываются)
- Если audio required для prediction (Tier-0 компоненты) → run = error
- Если audio optional (Tier-1) → run продолжается, в UI показываем предупреждение: "Видео не содержит аудио, некоторые компоненты недоступны"

#### Видео без кадров / очень короткие

- **Валидация на входе**: Backend проверяет длительность ДО создания run
- **Если < 5 секунд**: ошибка сразу (не создаём run)
- **Сообщение**: "Видео слишком короткое (минимум 5 секунд)"
- **Технически**: можно обработать и < 5 сек, но большинство алгоритмов требуют минимум несколько кадров для анализа

### 5) Таймауты

**Отложено до завершения DataProcessor baseline**. После baseline можно зафиксировать:
- Общий timeout: `max(2 часа, video_duration × 6)` (6x реального времени как запас)
- Timeout per component: `30 минут` (можно настраивать per component в конфиге)
- Segmenter timeout: `15 минут` (скачивание + сегментация)

**Важно**: таймауты должны быть конфигурируемыми через профиль анализа.

