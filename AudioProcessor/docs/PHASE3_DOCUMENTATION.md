# AudioProcessor – Документация третьей фазы

## Цель фазы
Довести систему до продакшн-уровня по производительности и надежности на больших массивах данных без упрощения качества признаков: оптимизировать синхронный конвейер, добавить микробатчинг/сегментацию длинных клипов, кэширование артефактов и удобные инструменты эксплуатации.

## Ключевые результаты фазы (что будет реализовано)
- Синхронный высокопроизводительный конвейер (CPU/GPU) с прогревом моделей
- Микробатчинг для CLAP (объединение коротких клипов в один прогон модели)
- Сегментация длинного аудио (скользящее окно без потери качества, агрегация эмбеддингов)
- Кэширование промежуточных артефактов (извлечённое WAV, мел- и MFCC-признаки, CLAP эмбеддинги)
- Идempotent-пайплайн: пропуск уже готовых шагов по хэшу входа/версии экстракторов
- Конфигурация производительности (threads, target_sr, device) через `config/settings.py`
- Утилиты профилирования и отчёты времени на этапах (per-extractor timing)

## Архитектура (дополнения фазы 3)
```
AudioProcessor/
├── src/
│   ├── core/
│   │   ├── main_processor.py          # Синхронный процессор (усовершенствованный)
│   │   ├── audio_utils.py             # Извлечение аудио сразу в 48 kHz, CPU/GPU IO
│   │   └── cache_utils.py             # (новое) Кэш и контроль версий артефактов
│   ├── extractors/
│   │   └── clap_extractor.py          # AMP на CUDA, потокобезопасная инициализация
│   └── utils/
│       └── profiling.py               # (новое) Таймеры и отчёты по этапам
├── run_local_processing.py            # Тюнинг потоков CPU, сравнительные прогоны
├── PHASE3_DOCUMENTATION.md            # Этот документ
└── requirements.txt
```

## Производительность и надёжность
- Прогрев моделей: однократный `warm_up()` при инициализации экстракторов
- Единый `target_sr=48000` при извлечении аудио для избежания повторных ресемплингов
- CUDA AMP для CLAP (меньше VRAM, быстрее инференс)
- Управление CPU-потоками через `torch.set_num_threads()` и переменные окружения (`OMP_NUM_THREADS`, `MKL_NUM_THREADS`)
- Чёткое логирование этапов и метрик (время шага, использование GPU-памяти)

## Микробатчинг CLAP
- Объединение нескольких коротких аудио-клипов до суммарной длины окна (например, 10s) в один прогон модели
- Разделение обратно на индивидуальные эмбеддинги и запись в manifest
- Конфигурируемый лимит: `clap_max_batch_audio_seconds`
- Польза: существенное ускорение на наборах множества коротких роликов

## Сегментация длинного аудио
- Скольжение окна (например, 10s с шагом 5s) → эмбеддинги на сегменты
- Агрегация: среднее/взвешенное/robust (настраиваемо) + сохранение покадровых эмбеддингов опционально
- Конфиги: `segment_window_seconds`, `segment_hop_seconds`, `segment_aggregate_mode`

## Кэширование артефактов
- Ключ кэша = хэш входного файла + версия экстрактора + параметры
- Кэшируются: извлечённый WAV, MFCC/Mel статистики, CLAP embeddings
- Поведение: при наличии валидного артефакта шаг пропускается, время обработки сокращается

## Формат результатов
- Manifest остаётся совместимым с фазами 1–2 (`audio_manifest_v1`)
- Для сегментации добавляются поля: `segments` (при включённом режиме), `aggregate_strategy`
- Для микробатчинга формат неизменен на уровне итогового manifest

## Настройки (дополнения)
- `PERF_THREADS` – количество потоков CPU (по умолчанию min(8, cores))
- `AUDIO_TARGET_SR` – целевая частота дискретизации при извлечении (по умолчанию 48000)
- `CLAP_ENABLE_AMP` – включение AMP на CUDA (true/false)
- `CLAP_MAX_BATCH_AUDIO_SECONDS` – лимит суммарной длительности аудио в микробатче
- `SEGMENT_WINDOW_SECONDS`, `SEGMENT_HOP_SECONDS`, `SEGMENT_AGGREGATE_MODE`
- `CACHE_DIR`, `CACHE_TTL_HOURS`, `CACHE_ENABLED`

## Тестирование и бенчмарки
- Наборы: короткие ролики (<=15s), длинные (>=2min)
- Сценарии:
  - Без кэша vs с кэшем
  - Без сегментации vs сегментация (качество/скорость)
  - Одиночные клипы vs микробатчи
- Метрики: total wall time, per-extractor time, speedup CPU↔GPU, VRAM usage

## Риски и меры
- Память GPU: контролировать суммарную длину микробатча; при OOM – падать в одиночную обработку
- Детерминизм: зафиксировать seed, версионировать параметры экстракторов в manifest
- Нагрузка на диск: кэш ограничивать TTL и размером, удалять неиспользуемые артефакты

## Выходные артефакты фазы
- Обновлённый синхронный пайплайн с прогревом и 48 kHz
- Реализация микробатчинга и/или сегментации (включаемо конфигом)
- Кэш промежуточных артефактов и контроль версий
- Подробные отчёты производительности и рекомендации по настройке

## Следующие шаги
- Интеграция сегментации/микробатчинга в API (если используется фаза 2)
- Расширение набора экстракторов из каталога `DataProcessor/extractors`
- Подготовка нагрузочных сценариев под реальные датасеты


